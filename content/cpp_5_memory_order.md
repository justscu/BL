编译乱序/CPU执行乱序 <br/>
volatile <br/>
spin_lock<br/>
std::atomic <br/>
C++11 memory order <br/>


CPU为了提高流水线的运行效率，会做出：（1）对无依赖的前后指令做适当的乱序和调度；（2）对控制依赖的指令做分支预测；（3）对读取内存等耗时操作，做提前预读...

`Sequential Consistency`, 顺序一致性，必须保障'每个处理器的指令执行顺序'和'程序给出的顺序'一致



### memory barrier / memory fence

为了保证内存访问的串行化，CPU提供了以下指令。其原理就是在访问内存时添加若干延时，保证“此指令以后的内存访问”发生在“此指令以前的内存访问”完成以后。即内存访问不会出现重叠(CPU乱序时).

```cpp
    inline void lfence() {
        __asm__ __volatile__("lfence" ::: "memory"); // load fence, 读串行
    }
    
    inline void sfence() {
        __asm__ __volatile__("sfence" ::: "memory"); // store fence, 写串行
    }
    
    inline void mfence() {
        __asm__ __volatile__("mfence" ::: "memory"); // load & store memory fence, 读写都串行
    }
```

对于多核心处理器，每个核心都有自己的缓存，而这些缓存并非都实时跟内存进行交互。
这样就会出现一个核心上的缓存数据，跟另外一个核心上的缓存数据不一致的问题。
该问题可能会导致程序异常。为了解决这个问题，操作系统提供内存屏障。内存屏障核心作用: <br/>
> (1) 阻止屏障两边的指令重排 <br/>
> (2) 强制把`写缓冲区/高速缓存`中的`脏数据`写回主存，让所有核心缓存中的相应数据失效。即保证所有核心跟内存中最新数据一致，保证数据有效性。<br/>

内存屏障分类 <br/>
> (1) lfence (load fence), 在`读指令前`插入读屏障，让高速缓存中的数据失效，重新从内存中加载数据 <br/>
> (2) sfence (store fence), 在`写指令后`插入写屏障，让写入高速缓存的最新数据都写回到主内存 <br/>
> (3) mfence，同时具有lfence和sfence能力 <br/>

Lock前缀 <br/>
Lock不是内存屏障，但提供了内存屏障类似功能。<br/>
> (1) 先对总线/缓存加锁，再执行后面的指令，再把高速缓存中的脏数据刷回主存，最后释放锁 <br/>
> (2) 通过Lock锁住总线的时候，其余CPU的读写操作都被阻塞，直到锁被释放。Lock锁住总线后的写操作，
会使其余cpu的相关cache line失效。<br/>


顺序一致性内存模型(Sequential Consistency, SC): 对程序的执行结果，有2个要求 (1)每个处理器的执行顺序和代码中的顺序一样; (2)所有处理器都只能看到一个单一的操作执行顺序.

全存储排序内存模型(Total Store Ording, TSO): 有些CPU架构，在处理器核心中，增加写缓存。一个写操作只要写入到本核心的写缓存中就可以返回。会导致其它线程看到的值还是之前的值。

松弛内存模型(Relaxed memory models)，在松弛内存模型中，编译器可以满足程序单线程执行结果的条件下，对代码进行重新排序。

内存栅栏(Memory Barrier)，由于缓存的出现，会导致一些操作不用到内存，就可以返回继续执行后面的操作。为了保证某些操作必须写入到内存后才执行，就引入了内存栅栏的操作。内存栅栏保证了，在栅栏指令之前的所有的内存操作的结果，都在栅栏指令之后的内存操作指令执行之前，被写入到内存中。即内存栅栏是一条显示的SC。
