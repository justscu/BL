### 6 存储器

#### 6.1 硬盘读写性能

Intel-730固态硬盘读写速度

操作                |性能         |操作                  |性能         |
--------------------|-------------|----------------------|-------------|
顺序读吞吐量        | 550 MB/s    | 顺序写吞吐量         | 470 MB/s    |
随机读吞吐量（IOPS）| 89 000 IOPS | 随机写吞吐量（IOPS） | 74 000 IOPS |
随机读吞吐量（MB/s）| 365 MB/s    | 随机写吞吐量（MB/s） | 303 MB/s    |
平均顺序读访问时间  | 50 us       | 平均顺序写访问时间   | 60 us       |

随机写慢的原因 <br/>
> 擦除块需要较长的时间(1ms级别)，比访问页的时间高出一个数量级；<br/>
> 如果写操作试图修改一个已经包含有数据的页p，那么这个块中所有包含有用数据的页都必须复制到一个新块(被擦除过的块)，然后才能进行对页p的写

#### 6.2 局部性原理

`时间局部性`，在一个具有良好时间局部性的程序中，被引用过一次的**内存位置**很可能在不远的将来会再被多次引用。<br/>
`空间局部性`，在一个具有良好空间局部性的程序中，如果一个内存位置被引用了一次，那么程序很可能在不远的将来会引用附近的一个内存位置。<br/>
有良好局部性的程序比局部性差的程序运行得更快。<br/>
> 重复引用相同变量的程序具有良好的时间局部性<br/>
> 对于数据，在内存中以大步长跳来跳去的程序空间局部性比较差<br/>
> 对于指令，循环具有较好的时间和空间局部性。循环体越小，迭代次数越多，局部性越好<br/>

#### 6.3 高速缓存

类型      | 缓存的内容 | 被缓存到何处     | 执行时间(周期数) | 由谁管理
----------|------------|------------------|-----------------:|----------
CPU寄存器 |4字节或8字节|芯片上的CPU寄存器 | 0                | 编译器
TLB       |地址翻译    |芯片上的TLB       | 0                | 硬件MMU
L1高速缓存|64字节块    |芯片上的L1高速缓存| 4                | 硬件
L2高速缓存|64字节块    |芯片外的L2高速缓存| 10               | 硬件
L3高速缓存|64字节块    |芯片外的L3高速缓存| 50               | 硬件
虚拟内存  |4KB页       |主存              | 200              | 硬件 + OS
缓冲区缓存|部分文件    |主存              | 200              | OS
磁盘缓存  |磁盘扇区    |磁盘控制器        | 100 000          | 控制器固件
网络缓存  |部分文件    |本地磁盘          | 10 000 000       | NFS客户

对L1高速缓存来说，命中时间的数量级是几个时钟周期 <br/>
L1不命中，需要从L2得到服务的处罚，通常是10个时钟周期；从L3得到服务的处罚是50个时钟周期；从主存得到服务的处罚是200个时钟周期 <br/>

![地址翻译](https://github.com/justscu/BL/blob/master/pics/CSAPP-6-cpu-cache-latency.png)

**如何编写高速缓存友好的代码**

> 让常见的情况运行得快。程序通常大部分时间都花在少量的核心函数上，函数大部分时间花在少量的循环上。要做好少量循环的优化 <br/>
> 尽量减少每个循环内部的缓存不命中数量(时间局部性、空间局部性) <br/>
> > 编译器一般会把局部变量缓存在寄存器文件中，所以对局部变量的引用效率非常高 <br/>
> > 存储器内部对数据一般是连续存储的，所以对数据步长为1的引用模式是好的 <br/>
> > 一旦从存储器中读取了一个数据对象，就要尽可能多的使用它，从而使程序的时间局部性最大 <br/>

> 减少static变量的引用。static变量存储在全局数据区，使用static变量会对缓存多次换入换出。<br/>
> 循环体内部代码要尽量短，这样指令缓存可以一次加载多次使用。而不是每次都刷新。<br/>

#### 6.4 Cache Line & False-Sharing

