###  5 程序性能优化

#### 5.1 循环可能会引起低效率

```cpp
int32_t get_length(DATA* d); // 返回DATA的长度

int32_t Test1(DATA* d) {
    int32_t ret = 0;
    // 这个地方，编译器不会把LEN(d)优化掉，而是多次求值
    for (int32_t i = 0; i < get_length(d); ++i) {
        ret += d[i].data;
    }
    return ret;
}

int32_t Test2(DATA* d) {
    int32_t ret = 0;
    int32_t len = get_length(d); // 只计算一次
    for (int32_t i = 0; i < len; ++i) {
        ret += d[i].data;
    }
}
```
get_length在Test1中会被调用多次，在Test2中只会被调用一次。<br/>
编译器无法确定get_length函数是否会对d造成影响，所以不会把Test1中的get_length给优化掉。


#### 5.2 减少不必要的函数调用
每次函数调用，都会有开销。应当尽量建设不必要的函数调用。

#### 5.3 消除不必要的内存引用
```
// 下面的例子，是个循环；计算结果保存在%rbx中、原始数据保存在%rdx中
.L17
  vmovsd (%rbx), %xmm0         -> 从内存中读取数据、加载到寄存器
  vmulsd (%rdx), %xmm0, %xmm0  -> 从内存中读取数据、和寄存器中数据相乘
  vmovsd %xmm0, (%rbx)         -> 把乘积保存到内存
  addq $8, %rdx                -> 移动指针到下一个数据
  cmpq %rax, %rdx
  jne .L17
```
```
.L17
  vmulsd (%rdx), %xmm0, %xmm0  -> 从内存中读取数据、与寄存器中值相乘
  addq       $8, %rdx          -> 移动指针到下一个数据
  cmpq     %rax, %rdx
  jne .L17
```
第一个例子有3次内存操作（两次读一次写），第二个例子有1次内存操作。

#### 5.4 现代处理器
现代处理器可以在一个时钟周期内完成多次操作，而且是乱序的(out-of-order)，即指令的执行顺序不一定与二进制代码的顺序一致。乱序会增加程序的并行度、但不会影响程序结果。

指令控制单元（ICU），从高速缓存中读取指令序列，并根据这些指令序列生成一组针对程序数据的基本操作。<br/>
执行单元（EU），执行这些操作。

#### 5.5 处理器性能

Intel-core7-haswell处理器延时

运算类型  | 延时 | 发射 | 容量
---------:|:----:|:----:|:----:|
整数加法  | 1    | 1    | 4
整数乘法  | 3    | 1    | 1
整数除法  | 3-30 | 3-30 | 1
浮点数加法| 3    | 1    | 1
浮点数乘法| 5    | 1    | 2
浮点数除法| 3-15 | 3-15 | 1

延时(latency)，完成一次运算需要的时钟周期数 <br/>
发射时间(issue time)，连续两次同类型的运算之间需要的最小时钟周期数 <br/>
容量(capacity)，能够执行该运算的功能单元数量 <br/>

为什么浮点数加法的发射为1？<br/>
一次浮点数加法的延时为3，但完成一次浮点数加法需要三个阶段(处理指数值、将小数相加、对结果进行舍入)，浮点数加法可以连续的通过各个阶段，而不是等待所有的都完成了再进行下一次浮点数加法。<br/>
即发射为1的都是完全流水线化的，每个时钟周期都可以开始一次新的计算。
一个计算多项式求值的例子`a[0] + a[1]*x + a[2]*x^2 + a[3]*x^3 + ... + a[n]*x^n`;

```cpp
// 算法一
// 数组a中存放a[0], a[1], a[2], ... , a[n]
double func1(const double a[], const double x, const long N) {
    double xpwr = x; // 计算 x ^ n
    double result = a[0];
    for (long i = 1; i <= N; ++i) {
        result += a[i] * xpwr; // (A)一次加法，一次乘法
        xpwr   *= x;           // (B)一次乘法
    }
    return result;
}

// 算法二
// a[0] + x(a[1] + x(a[2] + ... + x(a[n-1] + x*a[n])...))
double fun2(const double a[], const double x, const long N) {
    double result = a[N];
    for (long i = N-1; i >= 0; --i) {
        result = result * x + a[i]; // 一次加法，一次乘法
    }
    return result;
}
```
算法一执行2N次乘法和N次加法， CPE为5.
算法二执行N次乘法和N次加法，CPE为8.
算法二的执行时间要大于算法一。<br/>
算法一的A、B是可以并行的，没有依赖关系；但算法二的加法和乘法间是有依赖关系的。

寄存器限制<br/>
> 寄存器的个数是有限制的（16个浮点数寄存器、16个通用寄存器）。<br/>
> 局部变量在编译的时候，可以放到寄存器中。一旦寄存器不够的时候，会使用`栈`来保存局部变量，这个时候，速度就会变慢。

```
vmovsd 40(%rsp), %xmm0
vmulsd (%rdx), %xmm0, %xmm0
vmovsd %xmm0, 40(%rsp)
// 在栈上保存局部变量，指针偏移40.
```

提高程序性能的编码规则
> (1) 消除连续的函数调用。尽可能的将计算移到循环外。<br/>
> (2) 消除不必要的内存引用。引入临时变量来保存中间结果，只有在最后的值计算出来时，才将结果保存到数组或全局变量中。<br/>
> (3) 处理器有多个计算单元，在循环时，可以展开循环来降低开销，增加指令级的并行。即一次循环中多个乘法、加法运算，而不是一个。<br/>
> (4) 用功能性的风格重写条件操作，使得编译器采用条件数据传递。<br/>
